//Code generates prime factors of a given number
//Using an array of prime numbers generated 
//using discarded mathod of sieve of eratosthenes

#include <iostream>
#include <cstdio>
#include <cmath>
#include <ctime>

using namespace std;

typedef long L;                 //"%ld"
typedef long long LL;           //"%lld"
typedef long double LD;         //"%f"
typedef unsigned int UI;        // "%u"
typedef unsigned long  UL;      //"%lu"
typedef unsigned long long ULL; //"%llu"

short COUNT_;
#define sf scanf
#define pf printf
#define NL pf("\n");
#define SS pf(">_<LOOOOOK@MEEEEEEEEEEEEEEE<<( %d )>>\n",++COUNT_);
#define DD(x_) cout<<">>>>( "<<++COUNT_<<" ) "<<#x_<<": "<<x_<<endl;


//constants
const int stat_sz= 1E6;      //size of array to hold prime numbers
const int prime_sz= 8E4;	

bool stat[stat_sz+10];       //to mark composite as 1 then avoid them to generate primes
int primes[prime_sz];      //8E4 is enough for storing primes within 2-1E6 

void sieve(int);

//where the factors will be stored
int primeFactors[128];

//uses an array of prime numbers to factorize it
//the array is generated by the function sieve,
//Algorithm: Sieve of Eratosthenes
//Takes number, prime factorizes it
//returns the number of prime factors
template <typename T>
int factorize(T num)
{
    int factcc= 0; //counts #of prime factors
    T sqrtN= sqrt((double) num);
    
    for(int i= 0; primes[i]<=sqrtN; i++)
    {
        if(num % primes[i] == 0)
        {
            primeFactors[factcc]= primes[i];
//            cout<< primeFactors[factcc] <<" ";
            
            factcc++;
            while(num % primes[i] == 0)
            {
                num /= primes[i];
            }
        }
        
        //Narrowing down the range of factorization
        //Makes big difference in performance
        sqrtN= sqrt((double) num);
    }
    
    //incase the last factor got left out
    if(num != 1){
        primeFactors[factcc]= num;
//        cout<< primeFactors[factcc] <<endl;
        factcc++;
    }
    
    return factcc; //number of factors    
}


int main(void)
{
    sieve(1e6);
    
    int factcc= factorize(126548);
    
    cout<<endl<< factcc  <<endl;
    
    return 0;
}

void sieve(int N)
{
    int sqrtN= sqrt(double(N));
    int primeCount= 1;
    
    //marks all the odd composite numbers from 9 to [sz]    
    //even numbers are not marked as they are skipped altogether
    for(int i= 3, j; i<=sqrtN; i+=2)
    {
        if(stat[i] == 0)        //if not marked as composite yet/ don't want to mark twice
        {
            for(j = i*i; j<=N; j+= i<<1) //j+= 2i
            {
                stat[j]= 1; //marking this number as composite (corresponding to index number)
            }
            
        }
        
    }
    
    
    //setting 1st element as these loops only process odd numbers
    //pf("%d ", 2);
    primes[0]= 2; 
    
    //generates primes by skipping even numbers
    //and composite numbers marked by 'stat' array
    for(int i= 3, j= 1; i<=N; i+= 2)
    {
        if(stat[i] == 0)   //if not marked as composite
        {
            primes[j]= i;
//            pf("%d ", i);
//            pf("%d ", primes[j]);
            j++;
            primeCount++;
        }
        
    }
    
//    pf("\nPrime number count: %d\n", primeCount);
}


